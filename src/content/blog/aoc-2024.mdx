---
title: Advent of Code 2024
description: A log of my experience with Advent of Code 2024, there are spoilers in here so beware.
date: 2024-12-04
ogImage: /blog-og-images/aoc-2024.png
published: true
keywords:
    [
        "advent of code 2024",
        "advent of code solutions 2024",
        "aoc 2024 solutions",
        "advent of code 2024 answers",
        "advent of code 2024 day 1 solution",
        "advent of code 2024 day 2 solution",
        "advent of code 2024 day 3 solution",
        "advent of code 2024 day 4 solution",
        "advent of code 2024 day 5 solution",
        "advent of code 2024 day 6 solution",
        "aoc 2024 golang solutions",
        "advent of code go",
        "advent of code 2024 explained",
        "advent of code 2024 go",
        "advent of code 2024 walkthrough",
        "how to solve advent of code 2024",
        "programming puzzles",
        "coding challenges 2024",
        "go programming exercises",
        "daily coding problems",
        "algorithmic puzzles",
        "historian hysteria",
        "red-nosed reports",
        "mull it over",
        "ceres search",
        "print queue",
        "guard gallivant"
        "go optimization",
        "algorithm complexity",
        "advent of code 2024 tips",
        "aoc 2024 hints"
    ]
---

import Callout from "../../components/Callout.astro";

<br />

<Callout type="none">
    All of my Advent of Code solutions are available on
    [GitHub](https://github.com/dickeyy/adventofcode/tree/main/2024).
</Callout>

## Day 6: Guard Gallivant

Today's puzzle involved simulating a guard's patrol path in a grid-based map and predicting their
movements. The input consists of a grid where `^` represents the guard's starting position (facing
up) and `#` represents obstacles.

For Part 1, we needed to calculate how many distinct positions the guard would visit before leaving
the mapped area. The guard follows a simple protocol:

-   If there's an obstacle in front, turn right 90 degrees
-   Otherwise, move forward one step

My solution uses a Point and Direction system to track the guard's movement through the grid:

```go
type Point struct {
    x, y int
}

type Direction struct {
    dx, dy int
}

type Guard struct {
    pos Point
    dir Direction
}
```

Then we simulate the guard's movement using a map to track visited positions and implement the
protocol:

```go
func simulateGuardPath(grid [][]byte, guard Guard, checkLoop bool) int {
    visited := make(map[Point]bool)
    visited[guard.pos] = true

    for {
        next := Point{
            x: guard.pos.x + guard.dir.dx,
            y: guard.pos.y + guard.dir.dy,
        }

        if !isInBounds(next, grid) {
            break
        }

        if grid[next.y][next.x] == '#' {
            guard.turnRight()
            continue
        }

        guard.pos = next
        visited[guard.pos] = true
    }

    return len(visited)
}
```

Part 2 flipped the problem around - we needed to find positions where placing a new obstacle would
cause the guard to get stuck in a loop. This required modifying our simulation to detect repeated
states (position + direction combinations):

```go
type State struct {
    pos Point
    dir Direction
}

func simLoop(grid [][]byte, guard Guard) int {
    start := guard.pos
    count := 0

    for y := range grid {
        for x := range grid[y] {
            if grid[y][x] != '.' || (Point{x, y} == start) {
                continue
            }

            // create a copy of the grid with the new obstruction
            newGrid := make([][]byte, len(grid))
            for i := range grid {
                newGrid[i] = make([]byte, len(grid[i]))
                copy(newGrid[i], grid[i])
            }
            newGrid[y][x] = '#'

            if simulateGuardPath(newGrid, guard, true) > 0 {
                count++
            }
        }
    }
    return count
}
```

### Thoughts

Today's puzzle was a deceptively complex challenge in path simulation and state management. While
the initial rules seemed straightforward, implementing them correctly and especially handling Part 2
required significant problem-solving and careful debugging.

The trickiest aspects included:

1. Getting the turn mechanics exactly right - the subtle interplay between direction changes and
   movement needed precise implementation
2. Understanding that Part 2 wasn't just about finding places to put obstacles, but about finding
   positions that would create perfect loops
3. Realizing that detecting loops required tracking the complete state (position AND direction)
   because the same position could be visited multiple times in different directions as part of a
   valid patrol route
4. Managing the complexity of copying grids and running simulations for every possible obstacle
   position in Part 2 without missing edge cases

A key insight that took some time to reach was that the loop detection needed to look at the full
state of the guard - just tracking visited positions wasn't enough. This realization led to
implementing the State struct to capture both position and direction:

```go
type State struct {
    pos Point
    dir Direction
}
```

Performance-wise, Part 2 involves simulating the guard's path for every possible obstacle position,
which means we're doing a lot of grid copying and path simulation. While there might be cleverer
ways to optimize this by analyzing patterns in the guard's movement, sometimes the straightforward
approach, even if computationally intensive, is the most reliable path to a solution.

I'd rate this a 6/10 difficulty - while the core concepts aren't overly complex, getting all the
pieces working together correctly required solid problem-solving skills and careful debugging. The
leap from Part 1 to Part 2 was particularly challenging, requiring a fundamental shift in how we
thought about the problem and tracked the guard's state

_See you tomorrow!_

---

## Day 5: Print Queue

Today's puzzle involved managing a print queue for safety manual updates using topological sorting.
The input consisted of rules about page ordering (in the form X|Y meaning page X must be printed
before page Y) and sequences of pages that needed to be printed.

Part 1 required checking if given sequences of pages satisfied all the applicable ordering rules.
For example, if we had rules like `47|53` and `75|29`, we needed to verify that page 47 came before
53 and page 75 came before 29 in each sequence. My solution uses a directed graph to represent these
dependencies:

```go
func buildGraph(rules []Rule) Graph {
    graph := make(Graph)
    for _, rule := range rules {
        graph[rule.before] = append(graph[rule.before], rule.after)
    }
    return graph
}
```

Then for each squence, I check if it satisfies all applicable rules by tracking page positions and
verifying dependencies:

```go
func isValidSequence(seq []int, graph Graph) bool {
    positions := make(map[int]int)
    for i, page := range seq {
        positions[page] = i
    }

    for i := 0; i < len(seq); i++ {
        page := seq[i]
        if after, exists := graph[page]; exists {
            for _, mustBeAfter := range after {
                if pos, exists := positions[mustBeAfter]; exists {
                    if pos <= i {
                        return false
                    }
                }
            }
        }
    }
    return true
}
```

Part 2 flipped the problem around - instead of just validating sequences, we needed to correctly
order the invalid sequences using Kahn's topological sorting algorithm. This required tracking
in-degrees for each node and carefully managing the order of processing to match the expected
output:

```go
func topologicalSort(pages []int, fullGraph Graph) []int {
    // Create subgraph with only relevant pages...
    nodes := make(map[int]*Node)
    // Build dependencies...
    // Process queue in correct order...
    // Return sorted sequence...
}
```

Topological sort is a long algorithm in Go, so I didn't write it all here, but the full solution is
available on my [GitHub](https://github.com/dickeyy/adventofcode/blob/main/2024/day-5/main.go).

### Thoughts

Today's puzzle was a nice application of graph theory and topological sorting. While the core
concept wasn't too complex, getting all the edge cases right and ensuring the correct ordering in
Part 2 required careful implementation.

The trickiest part was handling Part 2's requirement to generate valid orderings. Making sure the
topological sort produced the correct ordering when multiple valid orderings were possible took some
debugging to get right. The key insight was realizing we needed to carefully manage the queue order
to ensure deterministic output.

The problem was also a good reminder of how important it is to properly model the problem space -
representing the dependencies as a directed graph made both parts much more straightforward to
solve.

I'd rate this a 5/10 difficulty - not overly complex conceptually, but requiring solid understanding
of graph algorithms and attention to detail in the implementation.

_See you tomorrow!_

---

## Day 4: Ceres Search

Today's puzzle was an interesting twist on the classic word search problem. Instead of searching for
a single instance of "XMAS", we needed to find all possible occurrences in Part 1, and then pivot to
finding X-shaped "MAS" patterns in Part 2.

There's quite a bit of code for today, so I'm not going to include it all here. As always, the full
solution is available on my
[GitHub](https://github.com/dickeyy/adventofcode/blob/main/2024/day-4/main.go).

For Part 1, I implemented a grid search that looks for "XMAS" in all eight possible directions
(horizontal, vertical, and diagonal) from any starting position. The approach uses direction vectors
to check each possible orientation:

```go
var dirs = []Direction{
    {0, 1},   // right
    {0, -1},  // left
    {1, 0},   // down
    {-1, 0},  // up
    {1, 1},   // down-right
    {1, -1},  // down-left
    {-1, 1},  // up-right
    {-1, -1}, // up-left
}
```

Part 2 required a different approach since we needed to find X-shaped patterns where each diagonal
spells either "MAS" or "SAM". I optimized this by only checking positions that contain 'A' (the
center of the X) and then validating the diagonals:

```go
if grid[row][col] == 'A' {
    if checkXMASCross(grid, row, col, rows, cols) {
        count++
    }
}
```

### Thoughts

Today's puzzle was quite the step up from the last one (in my opinion). While grid traversal and
pattern matchiing might sound straightforward, implementing both parts correctly required careful
thought and precise implementation.

The part that really made thhis puzzle tricky was handling all the edge cases correcly. In part 1,
ensuring the pattern checking worked in all eight directions while staying within bounds took some
debugging to get right. The pattern validation logic needed to be both efficient and thorough since
we were looking for all possible instances of "XMAS".

Part 2's X-pattern search was even more devious - it fundamentally changed how we needed to think
about the problem. The realization that we could optimize by starting from 'A' positions helped, but
validating the diagonal patterns correctly and handling the fact that "MAS" could be reversed added
extra complexity. Plus, the way the puzzle description led us to initially think about it in terms
of overlapping "MAS" strings, when really it was about finding X-shaped patterns, was quite clever.

Performance-wise, while both parts run quickly thanks to the optimized starting positions (X/A),
getting there required several refactoring attempts to handle all cases correctly while maintaining
efficiency.

I'd rate this a 5/10 difficulty - definitely more challenging than the first three days and
requiring some solid problem-solving skills to implement correctly. The misdirection in Part 2 and
the need for precise pattern matching logic made this a satisfyingly complex puzzle.

_See you tomorrow!_

---

## Day 3: Mull it Over

Today's puzzle was about parsing corrupted computer memory and extracting valid multiplication
instructions. The input consists of strings containing `mul(x,y)` patterns mixed with various
invalid characters and conditionals. Essentially it's a whole bunch of regex.

For part 1, you must find the number of valid `mul` instructions (where $x$ and $y$ are 1-3 digit
integers) and sum up their products. For example:

```
xmul(2,4)mul[3,7]a2mul(4,3)
```

Would be `(2*4) + (4*3) = 20`.

Only the properly formatted `mul(x,y)` patterns count. My solution uses regex to extract these
patters:

```go
func getMulNums(input string) [][]int {
    muls := make([][]int, 0)
    re := regexp.MustCompile(`mul\((\d+),(\d+)\)`)
    matches := re.FindAllStringSubmatchIndex(input, -1)

    // go on to process each match ...
}
```

You then just need to sum up the products of each pair.

Part 2 introduces conditional logic with `do()` and `don't()` instructions that enable or disable
multiplication operations. I modified the regex pattern to capture these new instructions and added
a boolean flag to track whether multiplications should be processed.

For this part, I just modified the regex pattern to capture these new instructions, added a
conditional boolean to the `getMulNums` function, and then added an `allowMul` boolean which (if the
conditional is true) would process the `do()` and `dont()` instructions.

```go
func getMulNums(input string, conditional bool) [][]int {
    // ...
    re := regexp.MustCompile(`mul\(\d+,\d+\)|do\(\)|don't\(\)`) // new regex
    // ...

    allowMul := true

	for _, match := range matches {
		op := input[match[0]:match[1]]

        // this part only happens if we are doing part 2
		if conditional {
			if op == "do()" {
				allowMul = true
			} else if op == "don't()" {
				allowMul = false
			}
		}

        // slightly modified from before due to the new conditional
		if allowMul && strings.HasPrefix(op, "mul") {
			muls = append(muls, extractNumsFromMul(op))
		}
	}

	return muls
}
```

Aside from these updates, I also made a `extractNumsFromMul` function to make my code a bit easier
to read:

```go
func extractNumsFromMul(op string) []int {
	numRe := regexp.MustCompile(`(\d+)`)
	nums := numRe.FindAllStringSubmatch(op, -1)
	x, _ := strconv.Atoi(nums[0][1])
	y, _ := strconv.Atoi(nums[1][1])
	return []int{x, y}
}
```

As always, the full solution is available on my
[GitHub](https://github.com/dickeyy/adventofcode/blob/main/2024/day-3/main.go).

### Thoughts

Today was an interesting exercise in string parsing and regex. While the core logic wasn't too
complex, getting the regex patterns right and handling the conditional state properly required some
careful thinking.

The biggest challenge was probably crafting the regex pattern to capture both the multiplication
instructions and the conditional statements while ignoring all the noise characters.

I'd rate this a 2/10 difficulty - not particularly difficult, just some clever regex.

_See you tomorrow!_

---

## Day 2: Red-Nosed Reports

Not too bad today to be honest. I got both parts done in < 45 minutes after I started, which
included an algorithm rewrite is not too bad for me.

Today's problem was about processing a $\mathbb{R}^{m\times n}$ matrix of integers. Each row is a
list of "levels". For each row, you need to verify it passes a few rules:

1. The row can only increase OR decrease, no switching part way through.
2. The difference between two consecutive levels must be between 1 and 3 (inclusive).

For part 1, you need to sum up the number of passing rows (rows that pass the above rules). For
example,

```
7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9
```

Has 2 safe rows (rows 1 and 6). Part 1 is pretty simple, once you have a working algorithm. Mine
looks like this:

```go
func isValidRow(row []int) bool {
    if len(row) < 2 {
        return true
    }

    // determine the initial direction from the first 2 nums
    isInc := row[1] > row[0]

    // check first pair meets difference criteria
    initialDiff := utils.Abs(row[1] - row[0])
    if initialDiff < 1 || initialDiff > 3 {
        return false
    }

    // check remaining pairs
    for i := 1; i < len(row)-1; i++ {
        curr, next := row[i], row[i+1]
        diff := next - curr

        // if direction changes, sequence is invalid
        if (diff > 0) != isInc {
            return false
        }

        // check the diff is within bounds
        if utils.Abs(diff) < 1 || utils.Abs(diff) > 3 {
            return false
        }
    }
    return true
}
```

_Note: `utils.Abs` is a helper function that can take in `int` rather than the `math.Abs` function
which takes in `float64`._

Go through each row in the matrix, if it is valid, increment the counter. Easy peasy.

For part 2, if a row is invalid, you need to now check if you can make it valid by removing any 1
level from the row. For example, the above matrix now has 4 safe rows (rows 1, 4, 5, and 6). I had
trouble figuring out how to do this efficiently, so it took some time, but I eventually came up with
this:

```go
func canBecomeValid(row []int) bool {
    // try removing each num and check if the resulting row is valid
    for i := range row {
        // create a new slice without the current num
        newRow := make([]int, 0, len(row)-1)
        newRow = append(newRow, row[:i]...)
        newRow = append(newRow, row[i+1:]...)

        if isValidRow(newRow) {
            return true
        }
    }
    return false
}
```

This just checks if a given row can become valid by removing any 1 level from the row, it tests
every number and then returns true if it can. You then modify the main function a bit for part 2 to
check if either `isValidRow` or `canBecomeValid` returns true, if so, increment the counter. Done!

### Thoughts

Today was a pretty cool problem. It seems trivial at first but then there are a few things that
catch you off guard. Still, relatively easy though, it will get harder the further into the month we
go.

This algorithm would be much easier in Python using `zip` and even day 1 would be easier with this
same function. I may write a `Zip2` function in Go as a util in the future since it's 2 days in a
row that my life would be so much easier. That said, this algorithm works and is still pretty fast.
Both parts ran in < 600 Âµs on my server. The point of AoC (for me) is not to write the most
efficient algorithm possible and not to get on the leaderboard, but to learn and improve. From doing
AoC for the past few years, I've learned a lot about algorithms and data structures, and in my book,
that's a win.

Overall, I'd give this a 3/10 difficulty, simply because it was a bit of work to find a
semi-efficient solution for part 2.

_See you tomorrow!_

---

## Day 1: Historian Hysteria

First day of AoC 2024! This year I decided to do all my solutions in [Go](https://golang.org).

Today's problem was pretty easy. You're given a list of integers, 2 in each row (separated by 3
spaces).

For part 1, you need to pair the smallest number on the left with the smallest on the right, then
the second smallest, then the third, and so on. For example,

```
1   4
3   1
4   3
8   2
```

Would be paired as `(1, 1), (3, 2), (4, 3), (8, 4)`. Then, you need to sum up the differences
between each pair. With the above example, the sum would be `0 + 1 + 1 + 4 = 6`.

My approach for part 1 was to first separate the numbers into two lists `left` and `right`, sort
them, and iterate over the left list calculating the absolute difference between each pair. Since we
know the right list is the same length as the left, we can just iterate over one and associate the
index with the other.

```go
left := make([]int, 0)
right := make([]int, 0)

// parse input ...

sort.Ints(left)
sort.Ints(right)

for i := 0; i < len(left); i++ {
    out += int(math.Abs(float64(left[i] - right[i])))
}
```

Pretty easy!

For part 2, you need to multiply each number in the left list by the number of times it appears in
the right list and sum up the results. For the above example, the result would be
`(1 * 1) + (3 * 1) + (4 * 1) + (8 * 1) = 16`.

My approach in part 2 was to make a hashmap of the right list associating each number with its
frequency, then iterate over the left list and multiply each number by its frequency in the hashmap.

```go
freq := make(map[int]int)
for _, num := range right {
    freq[num]++
}

for _, num := range left {
    if f, exists := freq[num]; exists {
        out += num * f
    }
}
```

For this part, you could use a nested for loop, but I wanted it to be a bit faster. The nested for
loop is O(n^2), whereas the hashmap is O(n).

### Thoughts

Super easy today. Looking back on last year's day 1 problem, this was a walk in the park. I had fun
optimizing my solution, and yes, I know it's not the most efficient algorithm, but it's easy to
understand and it works.

Overall, today was pretty easy, about a 1/10 difficulty.

_See you tomorrow!_
