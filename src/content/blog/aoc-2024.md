---
title: Advent of Code 2024
description: A log of my experience with Advent of Code 2024, there are spoilers in here so beware.
date: 2024-12-02
ogImage: /blog-og-images/aoc-2024.png
published: true
---

## Day 2: Red-Nosed Reports

Not too bad today to be honest. I got both parts done in <45 minutes after I started, which included
an algorithm rewrite is not too bad for me.

Today's problem was about processing a $\mathbb{R}^{m\times n}$ matrix of integers. Each row is a
list of "levels". For each row, you need to verify it passes a few rules:

1. The row can only increase OR decrease, no switching part way through.
2. The difference between two consecutive levels must be between 1 and 3 (inclusive).

For part 1, you need to sum up the number of passing rows (rows that pass the above rules). For
example,

```
7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9
```

Has 2 safe rows (rows 1 and 6). Part 1 is pretty simple, once you have a working algorithm. Mine
looks like this:

```go
func isValidRow(row []int) bool {
    if len(row) < 2 {
        return true
 }

    // determine the initial direction from the first 2 nums
 isInc := row[1] > row[0]

    // check first pair meets difference criteria
 initialDiff := utils.Abs(row[1] - row[0])
    if initialDiff < 1 || initialDiff > 3 {
        return false
 }

    // check remaining pairs
    for i := 1; i < len(row)-1; i++ {
 curr, next := row[i], row[i+1]
 diff := next - curr

        // if direction changes, sequence is invalid
        if (diff > 0) != isInc {
            return false
 }

        // check the diff is within bounds
        if utils.Abs(diff) < 1 || utils.Abs(diff) > 3 {
            return false
 }
 }

    return true
}
```

_Note: `utils.Abs` is a helper function that can take in `int` rather than the `math.Abs` function
which takes in `float64`._

Go through each row in the matrix, if it is valid, increment the counter. Easy peasy.

For part 2, if a row is invalid, you need to now check if you can make it valid by removing any 1
level from the row. For example, the above matrix now has 4 safe rows (rows 1, 4, 5, and 6). I had
trouble figuring out how to do this efficiently, so it took some time, but I eventually came up with
this:

```go
func canBecomeValid(row []int) bool {
    // try removing each num and check if the resulting row is valid
    for i := range row {
        // create a new slice without the current num
 newRow := make([]int, 0, len(row)-1)
 newRow = append(newRow, row[:i]...)
 newRow = append(newRow, row[i+1:]...)

        if isValidRow(newRow) {
            return true
 }
 }
    return false
}
```

This just checks if a given row can become valid by removing any 1 level from the row, it tests
every number and then returns true if it can. You then modify the main function a bit for part 2 to
check if either `isValidRow` or `canBecomeValid` returns true, if so, increment the counter. Done!

Overall, I'd give this a 3/10 difficulty, simply because it was a bit of work to find a
semi-efficient solution for part 2.

_See you tomorrow!_

---

## Day 1: Historian Hysteria

First day of AoC 2024! This year I decided to do all my solutions in [Go](https://golang.org).

Today's problem was pretty easy. You're given a list of integers, 2 in each row (separated by 3
spaces).

For part 1, you need to pair the smallest number on the left with the smallest on the right, then
the second smallest, then the third, and so on. For example,

```
1   4
3   1
4   3
8   2
```

Would be paired as `(1, 1), (3, 2), (4, 3), (8, 4)`. Then, you need to sum up the differences
between each pair. With the above example, the sum would be `0 + 1 + 1 + 4 = 6`.

My approach for part 1 was to first separate the numbers into two lists `left` and `right`, sort
them, and iterate over the left list calculating the absolute difference between each pair. Since we
know the right list is the same length as the left, we can just iterate over one and associate the
index with the other.

```go
left := make([]int, 0)
right := make([]int, 0)

// parse input ...

sort.Ints(left)
sort.Ints(right)

for i := 0; i < len(left); i++ {
 out += int(math.Abs(float64(left[i] - right[i])))
}
```

Pretty easy!

For part 2, you need to multiply each number in the left list by the number of times it appears in
the right list and sum up the results. For the above example, the result would be
`(1 * 1) + (3 * 1) + (4 * 1) + (8 * 1) = 16`.

My approach in part 2 was to make a hashmap of the right list associating each number with its
frequency, then iterate over the left list and multiply each number by its frequency in the hashmap.

```go
freq := make(map[int]int)
for _, num := range right {
 freq[num]++
}

for _, num := range left {
    if f, exists := freq[num]; exists {
 out += num * f
 }
}
```

For this part, you could use a nested for loop, but I wanted it to be a bit faster. The nested for
loop is O(n^2), whereas the hashmap is O(n).

Overall, today was pretty easy, about a 1/10 difficulty.

_See you tomorrow!_
