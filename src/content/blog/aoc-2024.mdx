---
title: Advent of Code 2024
description: A log of my experience with Advent of Code 2024, there are spoilers in here so beware.
date: 2024-12-03
ogImage: /blog-og-images/aoc-2024.png
published: true
keywords:
    [
        "advent of code 2024",
        "advent of code solutions 2024",
        "aoc 2024 solutions",
        "advent of code 2024 answers",
        "advent of code 2024 day 1 solution",
        "advent of code 2024 day 2 solution",
        "advent of code 2024 day 3 solution",
        "aoc 2024 golang solutions",
        "advent of code golang",
        "advent of code 2024 explained",
        "advent of code 2024 golang",
        "advent of code 2024 walkthrough",
        "how to solve advent of code 2024",
        "programming puzzles",
        "coding challenges 2024",
        "golang programming exercises",
        "daily coding problems",
        "algorithmic puzzles",
        "historian hysteria",
        "red-nosed reports",
        "mull it over",
        "golang optimization",
        "algorithm complexity",
        "advent of code 2024 tips",
        "aoc 2024 hints"
    ]
---

import Callout from "../../components/Callout.astro";

<br />

<Callout type="none">
    All of my Advent of Code solutions are available on
    [GitHub](https://github.com/dickeyy/adventofcode/tree/main/2024).
</Callout>

## Day 3: Mull it Over

Today's puzzle was about parsing corrupted computer memory and extracting valid multiplication
instructions. The input consists of strings containing `mul(x,y)` patterns mixed with various
invalid characters and conditionals. Essentially it's a whole bunch of regex.

For part 1, you must find the number of valid `mul` instructions (where $x$ and $y$ are 1-3 digit
integers) and sum up their products. For example:

```
xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))
```

Would be `(2*4 + 5*5 + 11*8 + 8*5) = 161`.

Only the properly formatted `mul(x,y)` patterns count. My solution uses regex to extract these
patters:

```go
func getMulNums(input string) [][]int {
    muls := make([][]int, 0)
    re := regexp.MustCompile(`mul\((\d+),(\d+)\)`)
    matches := re.FindAllStringSubmatchIndex(input, -1)

    // go on to process each match ...
}
```

You then just need to sum up the products of each pair.

Part 2 introduces conditional logic with `do()` and `don't()` instructions that enable or disable
multiplication operations. I modified the regex pattern to capture these new instructions and added
a boolean flag to track whether multiplications should be processed.

For this part, I just modified the regex pattern to capture these new instructions, added a
conditional boolean to the `getMulNums` function, and then added an `allowMul` boolean which (if the
conditional is true) would process the `do()` and `dont()` instructions.

```go
func getMulNums(input string, conditional bool) [][]int {
    // ...
    re := regexp.MustCompile(`mul\(\d+,\d+\)|do\(\)|don't\(\)`) // new regex
    // ...

    allowMul := true

	for _, match := range matches {
		op := input[match[0]:match[1]]

        // this part only happens if we are doing part 2
		if conditional {
			if op == "do()" {
				allowMul = true
			} else if op == "don't()" {
				allowMul = false
			}
		}

        // slightly modified from before due to the new conditional
		if allowMul && strings.HasPrefix(op, "mul") {
			muls = append(muls, extractNumsFromMul(op))
		}
	}

	return muls
}
```

Aside from these updates, I also made a `extractNumsFromMul` function to make my code a bit easier
to read:

```go
func extractNumsFromMul(op string) []int {
	numRe := regexp.MustCompile(`(\d+)`)
	nums := numRe.FindAllStringSubmatch(op, -1)
	x, _ := strconv.Atoi(nums[0][1])
	y, _ := strconv.Atoi(nums[1][1])
	return []int{x, y}
}
```

As always, the full solution is available on my
[GitHub](https://github.com/dickeyy/adventofcode/blob/main/2024/day-3/main.go).

### Thoughts

Today was an interesting exercise in string parsing and regex. While the core logic wasn't too
complex, getting the regex patterns right and handling the conditional state properly required some
careful thinking.

The biggest challenge was probably crafting the regex pattern to capture both the multiplication
instructions and the conditional statements while ignoring all the noise characters.

I'd rate this a 2/10 difficulty - not particularly difficult, just some clever regex.

_See you tomorrow!_

---

## Day 2: Red-Nosed Reports

Not too bad today to be honest. I got both parts done in < 45 minutes after I started, which
included an algorithm rewrite is not too bad for me.

Today's problem was about processing a $\mathbb{R}^{m\times n}$ matrix of integers. Each row is a
list of "levels". For each row, you need to verify it passes a few rules:

1. The row can only increase OR decrease, no switching part way through.
2. The difference between two consecutive levels must be between 1 and 3 (inclusive).

For part 1, you need to sum up the number of passing rows (rows that pass the above rules). For
example,

```
7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9
```

Has 2 safe rows (rows 1 and 6). Part 1 is pretty simple, once you have a working algorithm. Mine
looks like this:

```go
func isValidRow(row []int) bool {
    if len(row) < 2 {
        return true
    }

    // determine the initial direction from the first 2 nums
    isInc := row[1] > row[0]

    // check first pair meets difference criteria
    initialDiff := utils.Abs(row[1] - row[0])
    if initialDiff < 1 || initialDiff > 3 {
        return false
    }

    // check remaining pairs
    for i := 1; i < len(row)-1; i++ {
        curr, next := row[i], row[i+1]
        diff := next - curr

        // if direction changes, sequence is invalid
        if (diff > 0) != isInc {
            return false
        }

        // check the diff is within bounds
        if utils.Abs(diff) < 1 || utils.Abs(diff) > 3 {
            return false
        }
    }
    return true
}
```

_Note: `utils.Abs` is a helper function that can take in `int` rather than the `math.Abs` function
which takes in `float64`._

Go through each row in the matrix, if it is valid, increment the counter. Easy peasy.

For part 2, if a row is invalid, you need to now check if you can make it valid by removing any 1
level from the row. For example, the above matrix now has 4 safe rows (rows 1, 4, 5, and 6). I had
trouble figuring out how to do this efficiently, so it took some time, but I eventually came up with
this:

```go
func canBecomeValid(row []int) bool {
    // try removing each num and check if the resulting row is valid
    for i := range row {
        // create a new slice without the current num
        newRow := make([]int, 0, len(row)-1)
        newRow = append(newRow, row[:i]...)
        newRow = append(newRow, row[i+1:]...)

        if isValidRow(newRow) {
            return true
        }
    }
    return false
}
```

This just checks if a given row can become valid by removing any 1 level from the row, it tests
every number and then returns true if it can. You then modify the main function a bit for part 2 to
check if either `isValidRow` or `canBecomeValid` returns true, if so, increment the counter. Done!

### Thoughts

Today was a pretty cool problem. It seems trivial at first but then there are a few things that
catch you off guard. Still, relatively easy though, it will get harder the further into the month we
go.

This algorithm would be much easier in Python using `zip` and even day 1 would be easier with this
same function. I may write a `Zip2` function in Go as a util in the future since it's 2 days in a
row that my life would be so much easier. That said, this algorithm works and is still pretty fast.
Both parts ran in < 600 Âµs on my server. The point of AoC (for me) is not to write the most
efficient algorithm possible and not to get on the leaderboard, but to learn and improve. From doing
AoC for the past few years, I've learned a lot about algorithms and data structures, and in my book,
that's a win.

Overall, I'd give this a 3/10 difficulty, simply because it was a bit of work to find a
semi-efficient solution for part 2.

_See you tomorrow!_

---

## Day 1: Historian Hysteria

First day of AoC 2024! This year I decided to do all my solutions in [Go](https://golang.org).

Today's problem was pretty easy. You're given a list of integers, 2 in each row (separated by 3
spaces).

For part 1, you need to pair the smallest number on the left with the smallest on the right, then
the second smallest, then the third, and so on. For example,

```
1   4
3   1
4   3
8   2
```

Would be paired as `(1, 1), (3, 2), (4, 3), (8, 4)`. Then, you need to sum up the differences
between each pair. With the above example, the sum would be `0 + 1 + 1 + 4 = 6`.

My approach for part 1 was to first separate the numbers into two lists `left` and `right`, sort
them, and iterate over the left list calculating the absolute difference between each pair. Since we
know the right list is the same length as the left, we can just iterate over one and associate the
index with the other.

```go
left := make([]int, 0)
right := make([]int, 0)

// parse input ...

sort.Ints(left)
sort.Ints(right)

for i := 0; i < len(left); i++ {
    out += int(math.Abs(float64(left[i] - right[i])))
}
```

Pretty easy!

For part 2, you need to multiply each number in the left list by the number of times it appears in
the right list and sum up the results. For the above example, the result would be
`(1 * 1) + (3 * 1) + (4 * 1) + (8 * 1) = 16`.

My approach in part 2 was to make a hashmap of the right list associating each number with its
frequency, then iterate over the left list and multiply each number by its frequency in the hashmap.

```go
freq := make(map[int]int)
for _, num := range right {
    freq[num]++
}

for _, num := range left {
    if f, exists := freq[num]; exists {
        out += num * f
    }
}
```

For this part, you could use a nested for loop, but I wanted it to be a bit faster. The nested for
loop is O(n^2), whereas the hashmap is O(n).

### Thoughts

Super easy today. Looking back on last year's day 1 problem, this was a walk in the park. I had fun
optimizing my solution, and yes, I know it's not the most efficient algorithm, but it's easy to
understand and it works.

Overall, today was pretty easy, about a 1/10 difficulty.

_See you tomorrow!_
